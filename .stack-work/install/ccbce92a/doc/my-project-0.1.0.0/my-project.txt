-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Github at
--   <a>https://github.com/githubuser/my-project#readme</a>
@package my-project
@version 0.1.0.0


-- | This is a modulte that is implementing a dequeue and it's utilities.
module Dequeue

-- | Type that represents a dequeue.
data Dequeue a
Dequeue :: [a] -> Dequeue a

-- | Function that returns an empty dequeue.
emptyDEQ :: Dequeue a

-- | Function that takes a dequeue and returns <tt>True</tt> if it is empty
--   or <tt>Falese</tt> if it is not empty.
isEmptyDEQ :: Dequeue a -> Bool

-- | Function that takes a dequeue and returns it length.
lengthDEQ :: Dequeue a -> Int

-- | Function that takes a dequeue and returns the first element of it.
firstDEQ :: Dequeue a -> Maybe a

-- | Function that takes a dequeue and returns the last element of it.
lastDEQ :: Dequeue a -> Maybe a

-- | Function that takes a number n and returns an array of first n
--   elements in order they would be poped. If dequeue's length is smaller
--   then n, it returns array made out of all elements of the dequeue.
takeFrontDEQ :: Int -> Dequeue a -> [a]

-- | Function that takes a number n and returns an array of last n elements
--   in order they would be poped. If dequeue's length is smaller then n,
--   it returns array made out of all elements of the dequeue.
takeBackDEQ :: Int -> Dequeue a -> [a]

-- | Function that takes a dequeue and an element and adds it at the
--   beginning of the dequeue.
pushFrontDEQ :: Dequeue a -> a -> Dequeue a

-- | Function that takes a dequeue and returns a <tt>Just</tt> pair of the
--   first element and the dequeue without the element, if dequeue is empty
--   it returns <tt>Nothing</tt>.
popFrontDEQ :: Dequeue a -> Maybe (a, Dequeue a)

-- | Function that takes a dequeue and an element and adds it at the end of
--   the dequeue.
pushBackDEQ :: Dequeue a -> a -> Dequeue a

-- | Function that takes a dequeue and returns a <tt>Just</tt> pair of the
--   last element and the dequeue without the element, if dequeue is empty
--   it returns <tt>Nothing</tt>.
popBackDEQ :: Dequeue a -> Maybe (a, Dequeue a)

-- | Function that takes a list and returns a dequeue made out of that
--   list.
fromListDEQ :: [a] -> Dequeue a
instance GHC.Show.Show a => GHC.Show.Show (Dequeue.Dequeue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Dequeue.Dequeue a)


-- | This is a modulte that is implementing a pairing heap and it's
--   utilities.
module Heap

-- | Type that represents a Heap, it can be Empty, or it can have node that
--   has a list of it's chirldren.
data Heap a
EmptyH :: Heap a
Node :: a -> [Heap a] -> Heap a

-- | Fuction that takes a heap and return empty heap.
clearH :: Heap a -> Heap a

-- | Function that returns an empty heap.
emptyHe :: Heap a

-- | Function that takes a dequeue and returns <tt>True</tt> if it is empty
--   or <tt>Falese</tt> if it is not empty.
isEmptyHH :: Heap a -> Bool

-- | Function that takes an element and a heap and returns a heap with this
--   element added.
pushH :: (Ord a) => a -> Heap a -> Heap a

-- | Function that takes a heap and returns a <tt>Just</tt> pair of the
--   first element and the heap without the element, if heap is empty it
--   returns <tt>Nothing</tt>.
popH :: (Ord a) => Heap a -> Maybe (a, Heap a)

-- | Function that takes a reap and returns <tt>Just</tt> the element that
--   is on the top of the heap (the smallest element).
topH :: Heap a -> Maybe a

-- | Function that takes an array and returns a sotred array made out of
--   elements of taken array. It uses heap to sort the array.
heapSort :: (Ord a) => [a] -> [a]

-- | Function that takes an array and returns heap made out of the elements
--   of taken array.
makeHeapFromArray :: (Ord a) => [a] -> Heap a

-- | Function that takes a heap and returns a array made out of the heap.
--   It is sorted increasingly.
makeArrayFromHeap :: (Ord a) => Heap a -> [a]
instance GHC.Read.Read a => GHC.Read.Read (Heap.Heap a)
instance GHC.Show.Show a => GHC.Show.Show (Heap.Heap a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Heap.Heap a)

module Lib
someFunc :: IO ()
sayYo :: String -> String


-- | This is a modulte that is implementing a queue and it's utilities.
module Queue

-- | Type that represents a queue.
data Queue a
Queue :: [a] -> Queue a

-- | Function that returns an empty queue.
emptyQ :: Queue a

-- | Function tht takes a queue and returns <tt>True</tt> if it is emty or
--   <tt>False</tt> if it is not empty.
isEmptyQ :: Queue a -> Bool

-- | Function that takes an element and adds it to the queue.
addQ :: a -> Queue a -> Queue a

-- | Function that takes a queue a returns <tt>Just</tt> pair of the first
--   element and the queue without htis element, If queue is empty it
--   returns <tt>Nothing</tt>.
remQ :: Queue a -> Maybe (a, Queue a)
instance GHC.Show.Show a => GHC.Show.Show (Queue.Queue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Queue.Queue a)

module Stack
data Stack a
empty :: Stack a
isEmpty :: Stack a -> Bool
push :: a -> Stack a -> Stack a
top :: Stack a -> a
pop :: Stack a -> (a, Stack a)
